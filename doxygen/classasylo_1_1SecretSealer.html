<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.13"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Asylo: asylo::SecretSealer Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Asylo
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.13 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div id="nav-path" class="navpath">
  <ul>
<li class="navelem"><a class="el" href="namespaceasylo.html">asylo</a></li><li class="navelem"><a class="el" href="classasylo_1_1SecretSealer.html">SecretSealer</a></li>  </ul>
</div>
</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="#pub-static-methods">Static Public Member Functions</a> &#124;
<a href="classasylo_1_1SecretSealer-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">asylo::SecretSealer Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p>An abstract interface that must be provided by the various sealing roots.  
 <a href="classasylo_1_1SecretSealer.html#details">More...</a></p>

<p><code>#include &lt;<a class="el" href="secret__sealer_8h_source.html">secret_sealer.h</a>&gt;</code></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a0d3143ead62ab25b5b653ec184f6a077"><td class="memItemLeft" align="right" valign="top">&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a0d3143ead62ab25b5b653ec184f6a077">SecretSealer</a> ()=default</td></tr>
<tr class="separator:a0d3143ead62ab25b5b653ec184f6a077"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1639d4e4d3f866c38bd31d2709a8777d"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a1639d4e4d3f866c38bd31d2709a8777d">~SecretSealer</a> ()=default</td></tr>
<tr class="separator:a1639d4e4d3f866c38bd31d2709a8777d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a698599705c67ea2557edfa03efedff29"><td class="memItemLeft" align="right" valign="top">virtual SealingRootType&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a698599705c67ea2557edfa03efedff29">RootType</a> () const =0</td></tr>
<tr class="memdesc:a698599705c67ea2557edfa03efedff29"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sealing root type of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>.  <a href="#a698599705c67ea2557edfa03efedff29">More...</a><br /></td></tr>
<tr class="separator:a698599705c67ea2557edfa03efedff29"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a08dcfd32b295db7eb5fdc53ac177d2f1"><td class="memItemLeft" align="right" valign="top">virtual std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a08dcfd32b295db7eb5fdc53ac177d2f1">RootName</a> () const =0</td></tr>
<tr class="memdesc:a08dcfd32b295db7eb5fdc53ac177d2f1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sealing root name of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>.  <a href="#a08dcfd32b295db7eb5fdc53ac177d2f1">More...</a><br /></td></tr>
<tr class="separator:a08dcfd32b295db7eb5fdc53ac177d2f1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0c8f2132442f87e79e24904a66619cb6"><td class="memItemLeft" align="right" valign="top">virtual std::vector&lt; EnclaveIdentityExpectation &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a0c8f2132442f87e79e24904a66619cb6">RootAcl</a> () const =0</td></tr>
<tr class="memdesc:a0c8f2132442f87e79e24904a66619cb6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets the sealing root ACL of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>.  <a href="#a0c8f2132442f87e79e24904a66619cb6">More...</a><br /></td></tr>
<tr class="separator:a0c8f2132442f87e79e24904a66619cb6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af584b663c92f63fff7cfd3bc3eec3cff"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#af584b663c92f63fff7cfd3bc3eec3cff">SetDefaultHeader</a> (SealedSecretHeader *header) const =0</td></tr>
<tr class="memdesc:af584b663c92f63fff7cfd3bc3eec3cff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generates the default sealed-secret header based on the configuration of the <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a> and writes it to <code>header</code>.  <a href="#af584b663c92f63fff7cfd3bc3eec3cff">More...</a><br /></td></tr>
<tr class="separator:af584b663c92f63fff7cfd3bc3eec3cff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a34b4c3ac7b9b857949bd4ab2c6c23559"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a34b4c3ac7b9b857949bd4ab2c6c23559">Seal</a> (const SealedSecretHeader &amp;header, ByteContainerView additional_authenticated_data, ByteContainerView secret, SealedSecret *sealed_secret)=0</td></tr>
<tr class="memdesc:a34b4c3ac7b9b857949bd4ab2c6c23559"><td class="mdescLeft">&#160;</td><td class="mdescRight">Seals the input per the header specification.  <a href="#a34b4c3ac7b9b857949bd4ab2c6c23559">More...</a><br /></td></tr>
<tr class="separator:a34b4c3ac7b9b857949bd4ab2c6c23559"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae0bcb8d3990b493f9251d5797a8dbe19"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#ae0bcb8d3990b493f9251d5797a8dbe19">Unseal</a> (const SealedSecret &amp;sealed_secret, CleansingVector&lt; uint8_t &gt; *secret)=0</td></tr>
<tr class="memdesc:ae0bcb8d3990b493f9251d5797a8dbe19"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unseals the <code>sealed_secret</code> and writes it to <code>secret</code>.  <a href="#ae0bcb8d3990b493f9251d5797a8dbe19">More...</a><br /></td></tr>
<tr class="separator:ae0bcb8d3990b493f9251d5797a8dbe19"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abb322e705202a11fff2ab10b254bff99"><td class="memItemLeft" align="right" valign="top">virtual <a class="el" href="classasylo_1_1Status.html">Status</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#abb322e705202a11fff2ab10b254bff99">Reseal</a> (const SealedSecret &amp;old_sealed_secret, const SealedSecretHeader &amp;new_header, SealedSecret *new_sealed_secret)</td></tr>
<tr class="memdesc:abb322e705202a11fff2ab10b254bff99"><td class="mdescLeft">&#160;</td><td class="mdescRight">Re-seals an already sealed secret to a new header.  <a href="#abb322e705202a11fff2ab10b254bff99">More...</a><br /></td></tr>
<tr class="separator:abb322e705202a11fff2ab10b254bff99"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-static-methods"></a>
Static Public Member Functions</h2></td></tr>
<tr class="memitem:a3e3efc3f67478c870f296434f9b2106a"><td class="memItemLeft" align="right" valign="top">static <a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classasylo_1_1SecretSealer.html#a3e3efc3f67478c870f296434f9b2106a">GenerateSealerId</a> (SealingRootType type, const std::string &amp;name)</td></tr>
<tr class="memdesc:a3e3efc3f67478c870f296434f9b2106a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Combines the specified sealing root type and sealing root name to form a string.  <a href="#a3e3efc3f67478c870f296434f9b2106a">More...</a><br /></td></tr>
<tr class="separator:a3e3efc3f67478c870f296434f9b2106a"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>An abstract interface that must be provided by the various sealing roots. </p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a id="a0d3143ead62ab25b5b653ec184f6a077"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0d3143ead62ab25b5b653ec184f6a077">&#9670;&nbsp;</a></span>SecretSealer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">asylo::SecretSealer::SecretSealer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<a id="a1639d4e4d3f866c38bd31d2709a8777d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1639d4e4d3f866c38bd31d2709a8777d">&#9670;&nbsp;</a></span>~SecretSealer()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual asylo::SecretSealer::~SecretSealer </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span><span class="mlabel">default</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a id="a3e3efc3f67478c870f296434f9b2106a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a3e3efc3f67478c870f296434f9b2106a">&#9670;&nbsp;</a></span>GenerateSealerId()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">static <a class="el" href="classasylo_1_1StatusOr.html">StatusOr</a>&lt;std::string&gt; asylo::SecretSealer::GenerateSealerId </td>
          <td>(</td>
          <td class="paramtype">SealingRootType&#160;</td>
          <td class="paramname"><em>type</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">static</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Combines the specified sealing root type and sealing root name to form a string. </p>
<p>The combined string uniquely identifies the <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a> responsible for handling secrets associated with the particular combination of root-type <code>type</code> and root-name <code>name</code>.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">type</td><td>The root type for sealing (e.g., from <a class="el" href="classasylo_1_1SecretSealer.html#a698599705c67ea2557edfa03efedff29" title="Gets the sealing root type of this SecretSealer. ">RootType()</a>). </td></tr>
    <tr><td class="paramname">name</td><td>The root name for sealing (e.g., from <a class="el" href="classasylo_1_1SecretSealer.html#a08dcfd32b295db7eb5fdc53ac177d2f1" title="Gets the sealing root name of this SecretSealer. ">RootName()</a>). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>An object that represents a result string, or a failure status. </dd></dl>

</div>
</div>
<a id="abb322e705202a11fff2ab10b254bff99"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abb322e705202a11fff2ab10b254bff99">&#9670;&nbsp;</a></span>Reseal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classasylo_1_1Status.html">Status</a> asylo::SecretSealer::Reseal </td>
          <td>(</td>
          <td class="paramtype">const SealedSecret &amp;&#160;</td>
          <td class="paramname"><em>old_sealed_secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const SealedSecretHeader &amp;&#160;</td>
          <td class="paramname"><em>new_header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SealedSecret *&#160;</td>
          <td class="paramname"><em>new_sealed_secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Re-seals an already sealed secret to a new header. </p>
<p>The net effect of calling this method is same as unsealing the secret and then sealing it to the new header, and that is exactly how this method is implemented by the base class. A derived class of <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a> may choose to further optimize this method.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">old_sealed_secret</td><td>The sealed secret to re-seal. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">new_header</td><td>The metadata to guide the re-sealing. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">new_sealed_secret</td><td>The output sealed secret. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-OK status if re-sealing fails. </dd></dl>

</div>
</div>
<a id="a0c8f2132442f87e79e24904a66619cb6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0c8f2132442f87e79e24904a66619cb6">&#9670;&nbsp;</a></span>RootAcl()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::vector&lt;EnclaveIdentityExpectation&gt; asylo::SecretSealer::RootAcl </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sealing root ACL of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sealing root ACL of this object. </dd></dl>

</div>
</div>
<a id="a08dcfd32b295db7eb5fdc53ac177d2f1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a08dcfd32b295db7eb5fdc53ac177d2f1">&#9670;&nbsp;</a></span>RootName()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual std::string asylo::SecretSealer::RootName </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sealing root name of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sealing root name of this class. </dd></dl>

</div>
</div>
<a id="a698599705c67ea2557edfa03efedff29"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a698599705c67ea2557edfa03efedff29">&#9670;&nbsp;</a></span>RootType()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual SealingRootType asylo::SecretSealer::RootType </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Gets the sealing root type of this <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a>. </p>
<dl class="section return"><dt>Returns</dt><dd>The sealing root type of this class. </dd></dl>

</div>
</div>
<a id="a34b4c3ac7b9b857949bd4ab2c6c23559"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a34b4c3ac7b9b857949bd4ab2c6c23559">&#9670;&nbsp;</a></span>Seal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classasylo_1_1Status.html">Status</a> asylo::SecretSealer::Seal </td>
          <td>(</td>
          <td class="paramtype">const SealedSecretHeader &amp;&#160;</td>
          <td class="paramname"><em>header</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteContainerView&#160;</td>
          <td class="paramname"><em>additional_authenticated_data</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ByteContainerView&#160;</td>
          <td class="paramname"><em>secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">SealedSecret *&#160;</td>
          <td class="paramname"><em>sealed_secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Seals the input per the header specification. </p>
<p>The <code>header</code> must have its <code>secret_name</code>, <code>secret_version</code> and <code>secret_purpose</code> fields populated. If any of the remaining fields in the <code>header</code> are populated, then they must be compatible with the underlying sealing root.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">header</td><td>The metadata to guide the sealing. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">additional_authenticated_data</td><td>Unencrypted data that is bundled with the sealed secret. </td></tr>
    <tr><td class="paramdir"></td><td class="paramname">secret</td><td>The data to encrypt and seal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">sealed_secret</td><td>The output sealed secret. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-OK status if sealing fails. </dd></dl>

</div>
</div>
<a id="af584b663c92f63fff7cfd3bc3eec3cff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af584b663c92f63fff7cfd3bc3eec3cff">&#9670;&nbsp;</a></span>SetDefaultHeader()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classasylo_1_1Status.html">Status</a> asylo::SecretSealer::SetDefaultHeader </td>
          <td>(</td>
          <td class="paramtype">SealedSecretHeader *&#160;</td>
          <td class="paramname"><em>header</em></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Generates the default sealed-secret header based on the configuration of the <a class="el" href="classasylo_1_1SecretSealer.html" title="An abstract interface that must be provided by the various sealing roots. ">SecretSealer</a> and writes it to <code>header</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[out]</td><td class="paramname">header</td><td>The destination for the default SealedSecretHeader value. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-OK status if a default cannot be set. </dd></dl>

</div>
</div>
<a id="ae0bcb8d3990b493f9251d5797a8dbe19"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae0bcb8d3990b493f9251d5797a8dbe19">&#9670;&nbsp;</a></span>Unseal()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual <a class="el" href="classasylo_1_1Status.html">Status</a> asylo::SecretSealer::Unseal </td>
          <td>(</td>
          <td class="paramtype">const SealedSecret &amp;&#160;</td>
          <td class="paramname"><em>sealed_secret</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">CleansingVector&lt; uint8_t &gt; *&#160;</td>
          <td class="paramname"><em>secret</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Unseals the <code>sealed_secret</code> and writes it to <code>secret</code>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir"></td><td class="paramname">sealed_secret</td><td>The input secret to unseal. </td></tr>
    <tr><td class="paramdir">[out]</td><td class="paramname">secret</td><td>The destination for the unsealed secret. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>A non-OK <a class="el" href="classasylo_1_1Status.html" title="Status contains information about an error. ">Status</a> if unsealing fails. </dd></dl>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>asylo/identity/<a class="el" href="secret__sealer_8h_source.html">secret_sealer.h</a></li>
</ul>
</div><!-- contents -->
<!-- HTML footer for doxygen 1.8.13-->
<!-- start footer part -->
<hr class="footer"/>
</body>
</html>
